"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("@timberio/types");
const tools_1 = require("@timberio/tools");
// Set default options for Timber
const defaultOptions = {
    // Default sync endpoint (protocol + domain)
    endpoint: "https://logs.timber.io",
    // Maximum number of logs to sync in a single request to Timber.io
    batchSize: 1000,
    // Max interval (in milliseconds) before a batch of logs proceeds to syncing
    batchInterval: 1000,
    // Maximum number of sync requests to make concurrently
    syncMax: 5,
    // If true, errors/failed logs should be ignored
    ignoreExceptions: false,
};
/**
 * Timber core class for logging to the Timber.io service
 */
class Timber {
    /* CONSTRUCTOR */
    /**
     * Initializes a new Timber instance
     *
     * @param apiKey: string - Private API key for logging to Timber.io
     * @param options?: ITimberOptions - Optionally specify Timber options
     */
    constructor(apiKey, sourceKey, options) {
        // Middleware
        this._middleware = [];
        // Number of logs logged
        this._countLogged = 0;
        // Number of logs successfully synced with Timber
        this._countSynced = 0;
        // First, check we have a valid API key
        if (typeof apiKey !== "string" || apiKey === "") {
            throw new Error("Timber API key missing");
        }
        // Store the API key, to use for syncing with Timber.io
        this._apiKey = apiKey;
        // Store the source key, to connect the log to a particular source
        this._sourceKey = sourceKey;
        // Merge default and user options
        this._options = Object.assign({}, defaultOptions, options);
        // Create a throttler, for sync operations
        const throttle = tools_1.makeThrottle(this._options.syncMax);
        // Sync after throttling
        const throttler = throttle((logs) => {
            return this._sync(logs);
        });
        // Create a batcher, for aggregating logs by buffer size/interval
        const batcher = tools_1.makeBatch(this._options.batchSize, this._options.batchInterval);
        this._batch = batcher((logs) => {
            return throttler(logs);
        });
    }
    /* PRIVATE METHODS */
    getContextFromError(e) {
        return {
            stack: e.stack,
        };
    }
    /* PUBLIC METHODS */
    /**
     * Number of entries logged
     *
     * @returns number
     */
    get logged() {
        return this._countLogged;
    }
    /**
     * Number of log entries synced with Timber.io
     *
     * @returns number
     */
    get synced() {
        return this._countSynced;
    }
    /**
     * Log an entry, to be synced with Timber.io
     *
     * @param message: string - Log message
     * @param level (LogLevel) - Level to log at (debug|info|warn|error)
     * @param context: (Context) - Context (optional)
     * @returns Promise<ITimberLog> after syncing
     */
    async log(message, level = types_1.LogLevel.Info, context = {}) {
        // Check that we have a sync function
        if (typeof this._sync !== "function") {
            throw new Error("No Timber logger sync function provided");
        }
        // Increment log count
        this._countLogged++;
        // Start building the log message
        let log = Object.assign({ 
            // Implicit date timestamp
            dt: new Date(), 
            // Explicit level
            level }, context);
        // Determine the type of message...
        // Is this an error?
        if (message instanceof Error) {
            log = Object.assign({}, log, this.getContextFromError(message), { 
                // Add error message
                message: message.message });
        }
        else {
            log = Object.assign({}, log, { 
                // Add string message
                message });
        }
        // Pass the log through the middleware pipeline
        const transformedLog = await this._middleware.reduceRight((fn, pipedLog) => fn.then(pipedLog), Promise.resolve(log));
        try {
            // Push the log through the batcher, and sync
            await this._batch(transformedLog);
            // Increment sync count
            this._countSynced++;
        }
        catch (e) {
            // Catch any errors - re-throw if `ignoreExceptions` == false
            if (!this._options.ignoreExceptions) {
                throw e;
            }
        }
        // Return the resulting log
        return transformedLog;
    }
    /**
     *
     * Debug level log, to be synced with Timber.io
     *
     * @param message: string - Log message
     * @param context: (Pick<ITimberLog, "context">) - Context (optional)
     * @returns Promise<ITimberLog> after syncing
     */
    async debug(message, context = {}) {
        return this.log(message, types_1.LogLevel.Debug, context);
    }
    /**
     *
     * Info level log, to be synced with Timber.io
     *
     * @param message: string - Log message
     * @param context: (Pick<ITimberLog, "context">) - Context (optional)
     * @returns Promise<ITimberLog> after syncing
     */
    async info(message, context = {}) {
        return this.log(message, types_1.LogLevel.Info, context);
    }
    /**
     *
     * Warning level log, to be synced with Timber.io
     *
     * @param message: string - Log message
     * @param context: (Pick<ITimberLog, "context">) - Context (optional)
     * @returns Promise<ITimberLog> after syncing
     */
    async warn(message, context = {}) {
        return this.log(message, types_1.LogLevel.Warn, context);
    }
    /**
     *
     * Warning level log, to be synced with Timber.io
     *
     * @param message: string - Log message
     * @param context: (Pick<ITimberLog, "context">) - Context (optional)
     * @returns Promise<ITimberLog> after syncing
     */
    async error(message, context = {}) {
        return this.log(message, types_1.LogLevel.Error, context);
    }
    /**
     * Sets the sync method - i.e. the final step in the pipeline to get logs
     * over to Timber.io
     *
     * @param fn - Pipeline function to use as sync method
     */
    setSync(fn) {
        this._sync = fn;
    }
    /**
     * Add a middleware function to the logging pipeline
     *
     * @param fn - Function to add to the log pipeline
     * @returns void
     */
    use(fn) {
        this._middleware.push(fn);
    }
    /**
     * Remove a function from the pipeline
     *
     * @param fn - Pipeline function
     * @returns void
     */
    remove(fn) {
        this._middleware = this._middleware.filter(p => p !== fn);
    }
}
// noinspection JSUnusedGlobalSymbols
exports.default = Timber;
//# sourceMappingURL=base.js.map