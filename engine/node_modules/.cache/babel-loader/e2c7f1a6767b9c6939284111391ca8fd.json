{"ast":null,"code":"import { LOAD_DRIVER_MATCHES, LOAD_OWNER_MATCHES, MATCH_ERROR, LOAD_DRIVERS_INFO, LOAD_OWNERS_INFO } from \"./actionTypes\";\nexport function loadDriverMatches(date) {\n  return dispatch => {\n    fetch(\"/matches/matchlist/driver/\".concat(date)).then(response => response.json()).then(responseJson => {\n      if (responseJson.success) {\n        dispatch({\n          type: LOAD_DRIVER_MATCHES,\n          payload: responseJson.matches\n        });\n        const driverIDs = responseJson.matches.map(match => match.driverID);\n        dispatch(loadDriversInfo(driverIDs));\n      }\n    });\n  };\n}\nexport function loadOwnerMatches(date) {\n  return dispatch => {\n    fetch(\"/matches/matchlist/owner/\".concat(date)).then(response => response.json()).then(responseJson => {\n      if (responseJson.success) {\n        dispatch({\n          type: LOAD_OWNER_MATCHES,\n          payload: responseJson.matches\n        });\n        const ownerIDs = responseJson.matches.map(match => match.ownerID);\n        dispatch(loadOwnersInfo(ownerIDs));\n      }\n    });\n  };\n}\nexport function makeMatch(driverMatchID, ownerMatchID, date) {\n  return dispatch => {\n    fetch(\"/matches/makeMatch/\".concat(driverMatchID, \"/\").concat(ownerMatchID), {\n      method: 'POST'\n    }).then(response => response.json()).then(responseJson => {\n      if (responseJson.success) {\n        dispatch(loadOwnerMatches(date));\n        dispatch(loadDriverMatches(date));\n      } else {\n        dispatch({\n          type: MATCH_ERROR,\n          payload: responseJson.error\n        });\n      }\n    });\n  };\n}\nexport function loadDriversInfo(driverIDs) {\n  return dispatch => {\n    fetch(\"/user/getDrivers/\".concat(driverIDs)).then(response => response.json()).then(responseJson => {\n      if (responseJson.success) {\n        dispatch({\n          type: LOAD_DRIVERS_INFO,\n          payload: responseJson.drivers\n        });\n      }\n    });\n  };\n}\nexport function loadOwnersInfo(ownerIDs) {\n  return dispatch => {\n    fetch(\"user/getOwners/\".concat(ownerIDs)).then(response => response.json()).then(responseJson => {\n      console.log(responseJson);\n\n      if (responseJson.success) {\n        dispatch({\n          type: LOAD_OWNERS_INFO,\n          payload: responseJson.owners\n        });\n      }\n    });\n  };\n}","map":{"version":3,"sources":["/Users/mac/Desktop/oxo/engine/src/Pages/MatchList/Redux/actions.ts"],"names":["LOAD_DRIVER_MATCHES","LOAD_OWNER_MATCHES","MATCH_ERROR","LOAD_DRIVERS_INFO","LOAD_OWNERS_INFO","loadDriverMatches","date","dispatch","fetch","then","response","json","responseJson","success","type","payload","matches","driverIDs","map","match","driverID","loadDriversInfo","loadOwnerMatches","ownerIDs","ownerID","loadOwnersInfo","makeMatch","driverMatchID","ownerMatchID","method","error","drivers","console","log","owners"],"mappings":"AAAA,SACEA,mBADF,EAEEC,kBAFF,EAIEC,WAJF,EAKEC,iBALF,EAMEC,gBANF,QAOO,eAPP;AASA,OAAO,SAASC,iBAAT,CAA2BC,IAA3B,EAAuC;AAC5C,SAAQC,QAAD,IAAmB;AACxBC,IAAAA,KAAK,qCAA8BF,IAA9B,EAAL,CAA2CG,IAA3C,CAAgDC,QAAQ,IACtDA,QAAQ,CAACC,IAAT,EADF,EACmBF,IADnB,CACwBG,YAAY,IAAI;AACtC,UAAIA,YAAY,CAACC,OAAjB,EAA0B;AACxBN,QAAAA,QAAQ,CAAC;AACLO,UAAAA,IAAI,EAAEd,mBADD;AAELe,UAAAA,OAAO,EAAEH,YAAY,CAACI;AAFjB,SAAD,CAAR;AAIA,cAAMC,SAAS,GAAGL,YAAY,CAACI,OAAb,CAAqBE,GAArB,CAA0BC,KAAD,IAA+BA,KAAK,CAACC,QAA9D,CAAlB;AACAb,QAAAA,QAAQ,CAACc,eAAe,CAACJ,SAAD,CAAhB,CAAR;AACD;AACF,KAVD;AAWD,GAZD;AAaD;AAED,OAAO,SAASK,gBAAT,CAA0BhB,IAA1B,EAAsC;AAC3C,SAAQC,QAAD,IAAmB;AACxBC,IAAAA,KAAK,oCAA6BF,IAA7B,EAAL,CAA0CG,IAA1C,CAA+CC,QAAQ,IACrDA,QAAQ,CAACC,IAAT,EADF,EACmBF,IADnB,CACwBG,YAAY,IAAI;AACtC,UAAIA,YAAY,CAACC,OAAjB,EAA0B;AACxBN,QAAAA,QAAQ,CAAC;AACPO,UAAAA,IAAI,EAAEb,kBADC;AAEPc,UAAAA,OAAO,EAAEH,YAAY,CAACI;AAFf,SAAD,CAAR;AAIA,cAAMO,QAAQ,GAAGX,YAAY,CAACI,OAAb,CAAqBE,GAArB,CAA0BC,KAAD,IAA8BA,KAAK,CAACK,OAA7D,CAAjB;AACAjB,QAAAA,QAAQ,CAACkB,cAAc,CAACF,QAAD,CAAf,CAAR;AACD;AACF,KAVD;AAWD,GAZD;AAaD;AAED,OAAO,SAASG,SAAT,CAAmBC,aAAnB,EAA0CC,YAA1C,EAAgEtB,IAAhE,EAA4E;AACjF,SAAQC,QAAD,IAAmB;AACxBC,IAAAA,KAAK,8BAAuBmB,aAAvB,cAAwCC,YAAxC,GAAwD;AACzDC,MAAAA,MAAM,EAAE;AADiD,KAAxD,CAAL,CAEGpB,IAFH,CAEQC,QAAQ,IAChBA,QAAQ,CAACC,IAAT,EAHA,EAGiBF,IAHjB,CAGsBG,YAAY,IAAI;AACpC,UAAGA,YAAY,CAACC,OAAhB,EAAwB;AACtBN,QAAAA,QAAQ,CAACe,gBAAgB,CAAChB,IAAD,CAAjB,CAAR;AACAC,QAAAA,QAAQ,CAACF,iBAAiB,CAACC,IAAD,CAAlB,CAAR;AACD,OAHD,MAGO;AACLC,QAAAA,QAAQ,CAAC;AACPO,UAAAA,IAAI,EAAEZ,WADC;AAEPa,UAAAA,OAAO,EAAEH,YAAY,CAACkB;AAFf,SAAD,CAAR;AAID;AACF,KAbD;AAcD,GAfD;AAgBD;AAED,OAAO,SAAST,eAAT,CAAyBJ,SAAzB,EAA8C;AACjD,SAAQV,QAAD,IAAmB;AACtBC,IAAAA,KAAK,4BAAqBS,SAArB,EAAL,CAAuCR,IAAvC,CAA4CC,QAAQ,IAChDA,QAAQ,CAACC,IAAT,EADJ,EACqBF,IADrB,CAC0BG,YAAY,IAAI;AACtC,UAAIA,YAAY,CAACC,OAAjB,EAA0B;AACtBN,QAAAA,QAAQ,CAAC;AACLO,UAAAA,IAAI,EAAEX,iBADD;AAELY,UAAAA,OAAO,EAAEH,YAAY,CAACmB;AAFjB,SAAD,CAAR;AAIH;AACJ,KARD;AASH,GAVD;AAWH;AAED,OAAO,SAASN,cAAT,CAAwBF,QAAxB,EAA4C;AAC/C,SAAQhB,QAAD,IAAmB;AACtBC,IAAAA,KAAK,0BAAmBe,QAAnB,EAAL,CAAoCd,IAApC,CAAyCC,QAAQ,IAC7CA,QAAQ,CAACC,IAAT,EADJ,EACqBF,IADrB,CAC0BG,YAAY,IAAI;AACtCoB,MAAAA,OAAO,CAACC,GAAR,CAAYrB,YAAZ;;AACA,UAAIA,YAAY,CAACC,OAAjB,EAA0B;AACtBN,QAAAA,QAAQ,CAAC;AACLO,UAAAA,IAAI,EAAEV,gBADD;AAELW,UAAAA,OAAO,EAAEH,YAAY,CAACsB;AAFjB,SAAD,CAAR;AAIH;AACJ,KATD;AAUH,GAXD;AAYH","sourcesContent":["import {\n  LOAD_DRIVER_MATCHES,\n  LOAD_OWNER_MATCHES,\n  MAKE_MATCH,\n  MATCH_ERROR,\n  LOAD_DRIVERS_INFO,\n  LOAD_OWNERS_INFO\n} from \"./actionTypes\";\n\nexport function loadDriverMatches(date: Date) {\n  return (dispatch: any) => {\n    fetch(`/matches/matchlist/driver/${date}`).then(response =>\n      response.json()).then(responseJson => {\n      if (responseJson.success) {\n        dispatch({\n            type: LOAD_DRIVER_MATCHES,\n            payload: responseJson.matches\n        });\n        const driverIDs = responseJson.matches.map((match: {driverID: string}) => match.driverID);\n        dispatch(loadDriversInfo(driverIDs));\n      }\n    })\n  }\n}\n\nexport function loadOwnerMatches(date: Date) {\n  return (dispatch: any) => {\n    fetch(`/matches/matchlist/owner/${date}`).then(response =>\n      response.json()).then(responseJson => {\n      if (responseJson.success) {\n        dispatch({\n          type: LOAD_OWNER_MATCHES,\n          payload: responseJson.matches\n        });\n        const ownerIDs = responseJson.matches.map((match: {ownerID: string}) => match.ownerID);\n        dispatch(loadOwnersInfo(ownerIDs));\n      }\n    })\n  }\n}\n\nexport function makeMatch(driverMatchID: string, ownerMatchID: string, date: Date) {\n  return (dispatch: any) => {\n    fetch(`/matches/makeMatch/${driverMatchID}/${ownerMatchID}`, {\n        method: 'POST'\n    }).then(response =>\n    response.json()).then(responseJson => {\n      if(responseJson.success){\n        dispatch(loadOwnerMatches(date));\n        dispatch(loadDriverMatches(date));\n      } else {\n        dispatch({\n          type: MATCH_ERROR,\n          payload: responseJson.error\n        });\n      }\n    })\n  }\n}\n\nexport function loadDriversInfo(driverIDs: string[]) {\n    return (dispatch: any) => {\n        fetch(`/user/getDrivers/${driverIDs}`).then(response =>\n            response.json()).then(responseJson => {\n            if (responseJson.success) {\n                dispatch({\n                    type: LOAD_DRIVERS_INFO,\n                    payload: responseJson.drivers\n                })\n            }\n        })\n    }\n}\n\nexport function loadOwnersInfo(ownerIDs: string[]) {\n    return (dispatch: any) => {\n        fetch(`user/getOwners/${ownerIDs}`).then(response =>\n            response.json()).then(responseJson => {\n            console.log(responseJson);\n            if (responseJson.success) {\n                dispatch({\n                    type: LOAD_OWNERS_INFO,\n                    payload: responseJson.owners\n                });\n            }\n        })\n    }\n}\n"]},"metadata":{},"sourceType":"module"}