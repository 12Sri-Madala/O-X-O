{"ast":null,"code":"import { LOAD_DRIVER_MATCHES, LOAD_OWNER_MATCHES, MATCH_ERROR } from \"./actionTypes\"; //Passing the token through could be something to remove in the future.\n\nexport function loadDriverMatches(date, token) {\n  return dispatch => {\n    fetch(\"/matches/matchlist/driver/\".concat(date), {\n      headers: {\n        Authorization: \"Bearer \" + token\n      }\n    }).then(response => response.json()).then(responseJson => {\n      if (responseJson.success) {\n        dispatch({\n          type: LOAD_DRIVER_MATCHES,\n          payload: responseJson.matches\n        });\n      }\n    });\n  };\n}\nexport function loadOwnerMatches(date, token) {\n  return dispatch => {\n    fetch(\"/matches/matchlist/owner/\".concat(date), {\n      headers: {\n        Authorization: \"Bearer \" + token\n      }\n    }).then(response => response.json()).then(responseJson => {\n      if (responseJson.success) {\n        dispatch({\n          type: LOAD_OWNER_MATCHES,\n          payload: responseJson.matches\n        });\n      }\n    });\n  };\n}\nexport function makeConnection(driverMatchID, ownerMatchID, date, token) {\n  return async dispatch => {\n    const response = await fetch(\"/connection\", {\n      method: \"POST\",\n      headers: {\n        Authorization: \"Bearer \" + token,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify({\n        driverMatchID,\n        ownerMatchID\n      })\n    });\n    const responseJson = await response.json();\n\n    if (!responseJson.success) {\n      dispatch({\n        type: MATCH_ERROR,\n        payload: responseJson.errorMessage\n      });\n    }\n  };\n}","map":{"version":3,"sources":["/Users/mac/Desktop/oxo/engine/src/Pages/MatchList/Redux/actions.ts"],"names":["LOAD_DRIVER_MATCHES","LOAD_OWNER_MATCHES","MATCH_ERROR","loadDriverMatches","date","token","dispatch","fetch","headers","Authorization","then","response","json","responseJson","success","type","payload","matches","loadOwnerMatches","makeConnection","driverMatchID","ownerMatchID","method","body","JSON","stringify","errorMessage"],"mappings":"AAAA,SACEA,mBADF,EAEEC,kBAFF,EAGEC,WAHF,QAIO,eAJP,C,CAMA;;AAEA,OAAO,SAASC,iBAAT,CAA2BC,IAA3B,EAAuCC,KAAvC,EAAsD;AAC3D,SAAQC,QAAD,IAAmB;AACxBC,IAAAA,KAAK,qCAA8BH,IAA9B,GAAsC;AACzCI,MAAAA,OAAO,EAAE;AACPC,QAAAA,aAAa,EAAE,YAAYJ;AADpB;AADgC,KAAtC,CAAL,CAKGK,IALH,CAKQC,QAAQ,IAAIA,QAAQ,CAACC,IAAT,EALpB,EAMGF,IANH,CAMQG,YAAY,IAAI;AACpB,UAAIA,YAAY,CAACC,OAAjB,EAA0B;AACxBR,QAAAA,QAAQ,CAAC;AACPS,UAAAA,IAAI,EAAEf,mBADC;AAEPgB,UAAAA,OAAO,EAAEH,YAAY,CAACI;AAFf,SAAD,CAAR;AAID;AACF,KAbH;AAcD,GAfD;AAgBD;AAED,OAAO,SAASC,gBAAT,CAA0Bd,IAA1B,EAAsCC,KAAtC,EAAqD;AAC1D,SAAQC,QAAD,IAAmB;AACxBC,IAAAA,KAAK,oCAA6BH,IAA7B,GAAqC;AACxCI,MAAAA,OAAO,EAAE;AACPC,QAAAA,aAAa,EAAE,YAAYJ;AADpB;AAD+B,KAArC,CAAL,CAKGK,IALH,CAKQC,QAAQ,IAAIA,QAAQ,CAACC,IAAT,EALpB,EAMGF,IANH,CAMQG,YAAY,IAAI;AACpB,UAAIA,YAAY,CAACC,OAAjB,EAA0B;AACxBR,QAAAA,QAAQ,CAAC;AACPS,UAAAA,IAAI,EAAEd,kBADC;AAEPe,UAAAA,OAAO,EAAEH,YAAY,CAACI;AAFf,SAAD,CAAR;AAID;AACF,KAbH;AAcD,GAfD;AAgBD;AAED,OAAO,SAASE,cAAT,CACLC,aADK,EAELC,YAFK,EAGLjB,IAHK,EAILC,KAJK,EAKL;AACA,SAAO,MAAOC,QAAP,IAAyB;AAC9B,UAAMK,QAAQ,GAAG,MAAMJ,KAAK,CAAC,aAAD,EAAgB;AAC1Ce,MAAAA,MAAM,EAAE,MADkC;AAE1Cd,MAAAA,OAAO,EAAE;AACPC,QAAAA,aAAa,EAAE,YAAYJ,KADpB;AAEP,wBAAgB;AAFT,OAFiC;AAM1CkB,MAAAA,IAAI,EAAEC,IAAI,CAACC,SAAL,CAAe;AACnBL,QAAAA,aADmB;AAEnBC,QAAAA;AAFmB,OAAf;AANoC,KAAhB,CAA5B;AAWA,UAAMR,YAAY,GAAG,MAAMF,QAAQ,CAACC,IAAT,EAA3B;;AACA,QAAI,CAACC,YAAY,CAACC,OAAlB,EAA2B;AACzBR,MAAAA,QAAQ,CAAC;AACPS,QAAAA,IAAI,EAAEb,WADC;AAEPc,QAAAA,OAAO,EAAEH,YAAY,CAACa;AAFf,OAAD,CAAR;AAID;AACF,GAnBD;AAoBD","sourcesContent":["import {\n  LOAD_DRIVER_MATCHES,\n  LOAD_OWNER_MATCHES,\n  MATCH_ERROR\n} from \"./actionTypes\";\n\n//Passing the token through could be something to remove in the future.\n\nexport function loadDriverMatches(date: Date, token: string) {\n  return (dispatch: any) => {\n    fetch(`/matches/matchlist/driver/${date}`, {\n      headers: {\n        Authorization: \"Bearer \" + token\n      }\n    })\n      .then(response => response.json())\n      .then(responseJson => {\n        if (responseJson.success) {\n          dispatch({\n            type: LOAD_DRIVER_MATCHES,\n            payload: responseJson.matches\n          });\n        }\n      });\n  };\n}\n\nexport function loadOwnerMatches(date: Date, token: string) {\n  return (dispatch: any) => {\n    fetch(`/matches/matchlist/owner/${date}`, {\n      headers: {\n        Authorization: \"Bearer \" + token\n      }\n    })\n      .then(response => response.json())\n      .then(responseJson => {\n        if (responseJson.success) {\n          dispatch({\n            type: LOAD_OWNER_MATCHES,\n            payload: responseJson.matches\n          });\n        }\n      });\n  };\n}\n\nexport function makeConnection(\n  driverMatchID: string,\n  ownerMatchID: string,\n  date: Date,\n  token: string\n) {\n  return async (dispatch: any) => {\n    const response = await fetch(\"/connection\", {\n      method: \"POST\",\n      headers: {\n        Authorization: \"Bearer \" + token,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify({\n        driverMatchID,\n        ownerMatchID\n      })\n    });\n    const responseJson = await response.json();\n    if (!responseJson.success) {\n      dispatch({\n        type: MATCH_ERROR,\n        payload: responseJson.errorMessage\n      });\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"module"}