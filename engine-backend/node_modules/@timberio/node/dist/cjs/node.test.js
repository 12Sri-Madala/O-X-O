"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const os = __importStar(require("os"));
const path = __importStar(require("path"));
const fs = __importStar(require("fs"));
const stream_1 = require("stream");
const nock_1 = __importDefault(require("nock"));
const types_1 = require("@timberio/types");
const node_1 = require("./node");
/**
 * Create a log with a random string / current date
 */
function getRandomLog(message) {
    return {
        dt: new Date(),
        level: types_1.LogLevel.Info,
        message
    };
}
describe("node tests", () => {
    it("should echo log if timber sends 20x status code", async () => {
        const source = "someSource";
        nock_1.default("https://logs.timber.io")
            .post(`/sources/${source}/frames`)
            .reply(201);
        const message = String(Math.random());
        const expectedLog = getRandomLog(message);
        const node = new node_1.Node("valid api key", source);
        const echoedLog = await node.log(message);
        expect(echoedLog.message).toEqual(expectedLog.message);
    });
    it("should throw error if timber sends non 200 status code", async () => {
        const source = "someSource";
        nock_1.default("https://logs.timber.io")
            .post(`/sources/${source}/frames`)
            .reply(401);
        const node = new node_1.Node("invalid api key", "someSource");
        const message = String(Math.random);
        await expect(node.log(message)).rejects.toThrow();
    });
    it("should enable piping logs to a writable stream", async () => {
        // Create a writable stream
        const writeStream = new stream_1.Writable({
            write(chunk, encoding, callback) {
                // Will be a buffered JSON string -- parse
                const log = JSON.parse(chunk.toString());
                // Expect the log to match the message
                expect(log.message).toEqual(message);
                callback();
            }
        });
        // Fixtures
        const timber = new node_1.Node("test", "someSource");
        timber.pipe(writeStream);
        const message = "This should be streamed";
        // Mock the sync method by simply returning the same logs
        timber.setSync(async (logs) => logs);
        // Fire a log event
        await timber.log(message);
    });
    it("should pipe logs to a writable file stream", async (done) => {
        // Create a temporary file name
        const temp = path.join(os.tmpdir(), `timber_${Math.random()}`);
        // Create a write stream based on that temp file
        const writeStream = fs.createWriteStream(temp);
        // Create a Pass-through stream, to ensure multiplexing works
        const passThrough = new stream_1.PassThrough();
        // Pass write stream to Timber
        const timber = new node_1.Node("test", "someSource");
        timber.pipe(passThrough).pipe(writeStream);
        // Mock the sync method by simply returning the same logs
        timber.setSync(async (logs) => logs);
        // Create messages
        const messages = ["message 1", "message 2"];
        // Log messages
        await Promise.all(messages.map(msg => timber.log(msg)));
        writeStream.on("finish", () => {
            // Get the stored data, and translate back to JSON
            const data = fs
                .readFileSync(temp)
                .toString()
                .trim()
                .split("\n")
                .map(line => JSON.parse(line));
            // Messages should match
            for (let i = 0; i < messages.length; i++) {
                expect(data[i].message).toEqual(messages[i]);
            }
            done();
        });
        writeStream.end();
    });
});
//# sourceMappingURL=node.test.js.map